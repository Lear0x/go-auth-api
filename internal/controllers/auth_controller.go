package controllers

import (
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/Lear0x/go-auth-api/config"
	"github.com/Lear0x/go-auth-api/internal/models"
	"github.com/Lear0x/go-auth-api/pkg/utils"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt"
)

func Register(c *gin.Context) {
	var user models.User

	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Donn√©es invalides"})
		return
	}

	// V√©rifier si l'utilisateur existe d√©j√†
	var existingUser models.User
	if err := config.DB.Where("email = ?", user.Email).First(&existingUser).Error; err == nil {
		c.JSON(http.StatusConflict, gin.H{"error": "Cet email est d√©j√† utilis√©"})
		return
	}

	// Hasher le mot de passe avant de l'enregistrer
	if err := user.HashPassword(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur de hachage du mot de passe"})
		return
	}

	fmt.Println("Mot de passe APR√àS hachage :", user.Password)

	// Enregistrer l'utilisateur en base de donn√©es
	if err := config.DB.Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur d'enregistrement"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "Utilisateur cr√©√©"})
}

func Login(c *gin.Context) {
	var input struct {
		Email    string `json:"email" binding:"required,email"`
		Password string `json:"password" binding:"required"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		fmt.Println("üî¥ Erreur binding JSON :", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Donn√©es invalides"})
		return
	}

	fmt.Println("üì• Email re√ßu :", input.Email)
	fmt.Println("üì• Mot de passe re√ßu :", input.Password)

	var user models.User
	if err := config.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Utilisateur non trouv√©"})
		return
	}

	fmt.Println("üîç Utilisateur trouv√© :", user.Email)
	fmt.Println("üîç Mot de passe r√©cup√©r√© en base :", user.Password)

	if !user.CheckPassword(input.Password) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Mot de passe incorrect"})
		return
	}

	token, err := utils.GenerateToken(user.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur de g√©n√©ration du token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"token": token})
}

func ForgotPassword(c *gin.Context) {
	var input struct {
		Email string `json:"email" binding:"required,email"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Email invalide"})
		return
	}

	// V√©rifier si l'utilisateur existe
	var user models.User
	if err := config.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Utilisateur non trouv√©"})
		return
	}

	// G√©n√©rer un token temporaire (expire en 30 minutes)
	expirationTime := time.Now().Add(30 * time.Minute).Unix()
	secretKey := os.Getenv("JWT_SECRET")

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub": user.ID,
		"exp": expirationTime,
	})

	tokenString, err := token.SignedString([]byte(secretKey))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur lors de la g√©n√©ration du token"})
		return
	}

	// üîπ Normalement ici, on enverrait un email avec le lien contenant ce token.
	// Pour tester, on va juste afficher le token en r√©ponse.
	resetLink := fmt.Sprintf("http://localhost:8080/reset-password?token=%s", tokenString)

	c.JSON(http.StatusOK, gin.H{
		"message":     "Un lien de r√©initialisation a √©t√© envoy√©",
		"reset_token": tokenString, // √Ä remplacer par un vrai envoi d'email plus tard
		"reset_link":  resetLink,   // Juste pour test
	})
}

// ResetPassword v√©rifie le token et met √† jour le mot de passe
// ResetPassword met √† jour le mot de passe apr√®s v√©rification du token
func ResetPassword(c *gin.Context) {
	var input struct {
		Token       string `json:"token" binding:"required"`
		NewPassword string `json:"new_password" binding:"required,min=6"`
	}

	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Donn√©es invalides"})
		return
	}

	// V√©rifier le token
	secretKey := os.Getenv("JWT_SECRET")
	token, err := jwt.Parse(input.Token, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("Methode de signature invalide")
		}
		return []byte(secretKey), nil
	})

	if err != nil || !token.Valid {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Token invalide ou expir√©"})
		return
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Token corrompu"})
		return
	}

	// R√©cup√©rer l'ID utilisateur depuis le token
	userID := uint(claims["sub"].(float64))

	// R√©cup√©rer l'utilisateur
	var user models.User
	if err := config.DB.First(&user, userID).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Utilisateur non trouv√©"})
		return
	}

	// üîç V√©rifier avant mise √† jour
	fmt.Println("üîç Ancien mot de passe en base :", user.Password)

	// Hacher le nouveau mot de passe
	user.Password = input.NewPassword
	if err := user.HashPassword(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Erreur lors du hachage du mot de passe"})
		return
	}

	// üîç V√©rifier apr√®s hachage
	fmt.Println("üîê Nouveau mot de passe hach√© :", user.Password)

	// Mettre √† jour le mot de passe en base
	if err := config.DB.Model(&user).Update("password", user.Password).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Impossible de mettre √† jour le mot de passe"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Mot de passe mis √† jour avec succ√®s"})
}
